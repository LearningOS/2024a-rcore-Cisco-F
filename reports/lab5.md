# 实现功能
为tcb增加字段，表示其当前是否开启死锁检测。具体死锁检测的逻辑是，首先初始化矩阵，包括进程的已分配资源、需求资源量。通过循环查找一个满足条件的任务：该任务未完成且其需要的所有资源都小于等于当前可用的资源。如果找到这样的任务，则将该任务标记为完成，并将其已分配的资源释放；如果找不到这样的任务，则退出循环。同时，在mutex等结构的impl中，要实现require_resource方法，更新当前任务的已分配向量。

# 问答作业
1. 需要回收内存资源（进程地址空间、页表等）、打开的文件、tcb信息等。其他线程的tcb可能会被其上级pcb引用，这些信息需要被回收，因为不需要再调度这些线程
2. Mutex1：无论 wait_queue 中是否有等待的任务，都会先将 locked 设置为 false，然后检查 wait_queue；Mutex2：只有在 wait_queue 中没有等待的任务时，才将 locked 设置为 false。

    这样可能导致的问题是，在 Mutex1 中，即使 wait_queue 中有等待的任务，locked 也会被设置为 false。这可能导致在 add_task 之前，其他任务尝试获取锁，从而导致死锁。在 Mutex2 中，如果 wait_queue 中有等待的任务，locked 不会被设置为 false。这意味着锁仍然被认为是持有状态，直到等待的任务被唤醒并获取锁。这种实现更符合锁的语义，从这种情况上避免了死锁。

# 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 无

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> [项目文档](https://learningos.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html) ；询问了gpt有关死锁调度算法的逻辑

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。